//! The main application state and logic (`eframe::App` implementation).

use crate::{
    config::AppConfig,
    external,
    fs::{scanner, ScanStats}, // Use items from fs module
    model::{Check, FileId, FileNode},
    preview::{self, PreviewCache, PreviewContent}, // Use items from preview module
    report::{self, ReportFormat, ReportOptions},
    selection,
    task::{ScanMessage, TaskMessage}, // Use items from task module
    ui,                               // Use the ui module's drawing functions
};
use crossbeam_channel::{Receiver, Sender};
use egui::{style::Visuals, CentralPanel, Context, Key, Modifiers, SidePanel};
use rfd::MessageDialogResult;
use std::{
    collections::HashMap,
    fs as std_fs,
    path::PathBuf,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc, Mutex,
    },
    thread::JoinHandle,
};
use syntect::highlighting::ThemeSet;
use syntect::parsing::SyntaxSet;
use arboard::Clipboard;

/// Represents the types of background tasks the application can run.
#[allow(dead_code)]
#[derive(Debug)]
pub(crate) enum BackgroundTask {
    /// A directory scan task. Holds the thread handle and cancellation signal.
    Scan(JoinHandle<()>, Arc<AtomicBool>),
    /// A report generation task. Holds the thread handle.
    Report(JoinHandle<()>),
}

/// The main application struct, holding all state and implementing `eframe::App`.
pub struct CodebaseApp {
    // --- Configuration ---
    /// Application configuration, loaded and saved via `config.rs`.
    pub(crate) config: AppConfig,

    // --- UI State ---
    /// The ID of the currently selected node in the tree view.
    pub(crate) selected_node_id: Option<FileId>,
    /// Current text in the tree view search box.
    pub(crate) search_text: String,
    /// Message displayed in the status bar.
    pub(crate) status_message: String,
    /// Cache for the currently displayed file preview content.
    /// Wrapped in Arc<Mutex> for thread-safe access from preview generation thread.
    pub(crate) preview_cache: Option<Arc<Mutex<PreviewCache>>>,
    /// Whether the preview panel is currently visible.
    pub(crate) show_preview_panel: bool,
    /// Whether the preferences dialog is open.
    pub(crate) show_preferences_window: bool,
    /// Whether the report options dialog is open.
    pub(crate) show_report_options_window: bool,
    /// Whether the about dialog is open.
    pub(crate) show_about_window: bool,
    /// Whether the keyboard shortcuts dialog is open.
    pub(crate) show_shortcuts_window: bool,
    /// Stores the options used for the last report generation.
    pub(crate) last_report_options: ReportOptions,
    /// Flag to signal the UI to focus the search box on the next frame.
    pub(crate) focus_search_box: bool,
    /// Draft configuration used while the preferences window is open.
    pub(crate) prefs_draft: Option<AppConfig>,
    /// Draft report options used while the report options window is open.
    pub(crate) report_options_draft: Option<ReportOptions>,

    // --- Data State ---
    /// Arena storing all file tree nodes (`FileNode`). Indexed by `FileId`.
    pub(crate) nodes: Vec<FileNode>,
    /// The `FileId` of the root node of the currently loaded directory.
    pub(crate) root_id: Option<FileId>,
    /// The absolute path of the currently loaded directory.
    pub(crate) root_path: Option<PathBuf>,
    /// Statistics gathered during the last scan.
    pub(crate) scan_stats: Option<ScanStats>,
    /// Temporary storage for child nodes whose parent hasn't been received yet during scan.
    /// Key: Parent's absolute path. Value: List of (ChildId, ChildPath).
    orphaned_children: HashMap<PathBuf, Vec<(FileId, PathBuf)>>,

    /// Map from absolute path to FileId for fast parent lookups during scan.
    path_to_id_map: HashMap<PathBuf, FileId>,

    // --- Background Task State ---
    /// Receiver for messages from the background scanner thread.
    pub(crate) scan_receiver: Option<Receiver<ScanMessage>>,
    /// Receiver for preview content generated by background threads.
    pub(crate) preview_receiver: Option<Receiver<(FileId, PreviewCache)>>,
    /// Sender used by the UI thread to request preview generation.
    pub(crate) preview_sender: Option<Sender<(FileId, PreviewCache)>>,
    /// Receiver for messages from the background report generation thread.
    pub(crate) task_receiver: Option<Receiver<TaskMessage>>,
    /// Sender used by the UI thread to initiate report generation.
    pub(crate) task_sender: Option<Sender<TaskMessage>>,
    /// Holds information about the currently running background task, if any.
    pub(crate) background_task: Option<BackgroundTask>,
    /// Quick flag indicating if a scan is in progress (synced with `background_task`).
    pub(crate) is_scanning: bool,
    /// Quick flag indicating if report generation is in progress (synced with `background_task`).
    pub(crate) is_generating_report: bool,

    // --- Syntax Highlighting Assets ---
    /// Reference to the loaded syntax set (from `syntect`).
    pub(crate) syntax_set: &'static SyntaxSet,
    /// Reference to the loaded theme set (from `syntect`).
    pub(crate) theme_set: &'static ThemeSet,

    // --- UI Action Deferral ---
    /// Queue for actions triggered by UI events, processed at the end of the frame.
    /// This avoids mutable borrows of `self` during UI drawing.
    pub(crate) deferred_actions: Vec<AppAction>,
}

/// Represents actions that modify the application state, often triggered by UI events.
/// These are queued in `deferred_actions` and processed after the UI draw pass.
#[derive(Debug)]
pub(crate) enum AppAction {
    /// Toggle the check state (Checked/Unchecked/Partial) of a node and its descendants.
    ToggleCheckState(FileId),
    /// Toggle the expanded/collapsed state of a directory node.
    ToggleExpandState(FileId),
    /// Select all nodes in the tree.
    SelectAllNodes,
    /// Deselect all nodes in the tree.
    DeselectAllNodes,
    /// Expand all directory nodes in the tree.
    ExpandAllNodes,
    /// Collapse all directory nodes (except the root).
    CollapseAllNodes,
    /// Select all direct children of a given directory node.
    SelectAllChildren(FileId),
    /// Deselect all direct children of a given directory node.
    DeselectAllChildren(FileId),
    /// Open the selected node's path using the system's default application.
    OpenNodeExternally(FileId),
    /// Prompt the user to save the current tree selection state to a file.
    SaveSelection,
    /// Prompt the user to load a previously saved selection state from a file.
    LoadSelection,
    /// Generate a report with the specified options.
    GenerateReport(ReportOptions),
    /// Generate a report and copy the output to the clipboard.
    CopyReport(ReportOptions),
    /// Start scanning a new directory path.
    StartScan(PathBuf),
    /// Request cancellation of the currently running scan.
    CancelScan,
    /// Set the focus to the tree view search box.
    FocusSearchBox,
}

impl CodebaseApp {
    /// Creates a new instance of the `CodebaseApp`.
    ///
    /// # Arguments
    ///
    /// * `cc` - The eframe creation context, used for accessing egui context and storage.
    /// * `syntax_set` - A static reference to the loaded `SyntaxSet`.
    /// * `theme_set` - A static reference to the loaded `ThemeSet`.
    pub fn new(
        cc: &eframe::CreationContext<'_>,
        syntax_set: &'static SyntaxSet,
        theme_set: &'static ThemeSet,
    ) -> Self {
        let config = AppConfig::load();
        Self::set_egui_theme(&cc.egui_ctx, &config.theme);

        // Create channels for background task communication
        let (preview_tx, preview_rx) = crossbeam_channel::unbounded();
        let (task_tx, task_rx) = crossbeam_channel::unbounded();

        // Initialize last report options based on loaded config
        let last_report_options = ReportOptions {
            format: match config.export_format.as_str() {
                "html" => ReportFormat::Html,
                "text" => ReportFormat::Text,
                _ => ReportFormat::Markdown, // Default to Markdown
            },
            include_stats: config.export_include_stats,
            include_contents: config.export_include_contents,
        };

        Self {
            config,
            last_report_options,
            selected_node_id: None,
            search_text: String::new(),
            status_message: "Ready. Select a directory to open (File > Open Directory)."
                .to_string(),
            preview_cache: None,
            show_preview_panel: true,
            show_preferences_window: false,
            show_report_options_window: false,
            show_about_window: false,
            show_shortcuts_window: false,
            focus_search_box: false,
            nodes: Vec::new(),
            root_id: None,
            root_path: None,
            scan_stats: Some(ScanStats::default()), // Initialize with default stats
            scan_receiver: None,
            preview_receiver: Some(preview_rx),
            preview_sender: Some(preview_tx),
            task_receiver: Some(task_rx),
            task_sender: Some(task_tx),
            background_task: None,
            is_scanning: false,
            is_generating_report: false,
            syntax_set,
            theme_set,
            deferred_actions: Vec::new(),
            orphaned_children: HashMap::new(),
            path_to_id_map: HashMap::new(), // Initialize the new map
            prefs_draft: None,
            report_options_draft: None,
        }
    }

    /// Queues an action to be processed after the current UI update cycle.
    pub(crate) fn queue_action(&mut self, action: AppAction) {
        self.deferred_actions.push(action);
    }

    /// Processes all actions queued in `deferred_actions`.
    fn process_deferred_actions(&mut self) {
        // Collect actions to avoid borrowing issues if an action queues another action
        let actions_to_process: Vec<AppAction> = self.deferred_actions.drain(..).collect();
        for action in actions_to_process {
            log::debug!("Processing action: {:?}", action);
            match action {
                AppAction::ToggleCheckState(id) => self.perform_toggle_check_state(id),
                AppAction::ToggleExpandState(id) => self.perform_toggle_expand_state(id),
                AppAction::SelectAllNodes => self.perform_select_all_nodes(),
                AppAction::DeselectAllNodes => self.perform_deselect_all_nodes(),
                AppAction::ExpandAllNodes => self.perform_expand_all_nodes(),
                AppAction::CollapseAllNodes => self.perform_collapse_all_nodes(),
                AppAction::SelectAllChildren(id) => self.perform_select_all_children(id),
                AppAction::DeselectAllChildren(id) => self.perform_deselect_all_children(id),
                AppAction::OpenNodeExternally(id) => self.perform_open_node_externally(id),
                AppAction::SaveSelection => self.perform_save_selection(),
                AppAction::LoadSelection => self.perform_load_selection(),
                AppAction::GenerateReport(opts) => self.perform_generate_report(opts),
                AppAction::CopyReport(opts) => self.perform_copy_report(opts),
                AppAction::StartScan(path) => self.perform_start_scan(path),
                AppAction::CancelScan => self.perform_cancel_scan(),
                AppAction::FocusSearchBox => self.perform_focus_search_box(),
            }
        }
    }

    // --- Action Implementations ---
    // These methods contain the core logic for each AppAction.

    /// Starts a background scan of the specified directory path.
    fn perform_start_scan(&mut self, path: PathBuf) {
        if self.is_scanning || self.is_generating_report {
            log::warn!("Cannot start scan: Another background task is running.");
            self.status_message = "Busy with another task (scan/report).".to_string();
            return;
        }

        log::info!("Starting scan for directory: {}", path.display());

        // Update state for the new scan
        self.root_path = Some(path.clone());
        self.config.add_recent_project(path.clone());
        if let Err(e) = self.config.save() {
            log::error!("Failed to save config after adding recent project: {}", e);
            // Non-critical, continue scan
        }

        self.nodes.clear();
        self.root_id = None;
        self.selected_node_id = None;
        self.scan_stats = Some(ScanStats::default());
        self.preview_cache = None; // Clear preview
        self.orphaned_children.clear(); // Clear any previous orphans
        self.path_to_id_map.clear(); // Clear the path map for the new scan
        self.status_message = format!(
            "Scanning {}...",
            path.file_name().map_or_else(
                || path.display().to_string(),
                |n| n.to_string_lossy().to_string()
            )
        );
        self.is_scanning = true;

        // Create channel for this scan
        let (sender, receiver) = crossbeam_channel::unbounded();
        self.scan_receiver = Some(receiver);

        // Spawn the scanner thread
        let (handle, cancel_signal) = scanner::scan(path, self.config.show_hidden_files, sender);
        self.background_task = Some(BackgroundTask::Scan(handle, cancel_signal));
    }

    /// Requests cancellation of the ongoing scan task.
    fn perform_cancel_scan(&mut self) {
        if let Some(BackgroundTask::Scan(_, cancel_signal)) = &self.background_task {
            log::info!("Requesting scan cancellation...");
            // Signal the scanner thread to stop
            cancel_signal.store(true, Ordering::Relaxed);
            self.status_message = "Scan cancellation requested...".to_string();
            // The scanner thread will eventually send ScanMessage::Finished
        } else {
            log::warn!("No active scan to cancel.");
        }
    }

    /// Toggles the check state of a node and updates ancestors.
    fn perform_toggle_check_state(&mut self, node_id: FileId) {
        let new_state = if let Some(node) = self.nodes.get(node_id) {
            match node.state {
                Check::Checked | Check::Partial => Check::Unchecked,
                Check::Unchecked => Check::Checked,
            }
        } else {
            log::warn!(
                "Attempted to toggle check state for invalid node ID: {}",
                node_id
            );
            return;
        };

        // Apply the new state recursively down the tree
        self.set_node_state_recursive(node_id, new_state);
        // Update the partial/checked state of parent nodes up the tree
        self.update_parent_states(node_id);
        log::trace!("Toggled check state for node {}", node_id);
    }

    /// Toggles the expanded/collapsed state of a directory node.
    fn perform_toggle_expand_state(&mut self, node_id: FileId) {
        if let Some(node) = self.nodes.get_mut(node_id) {
            if node.is_dir() {
                node.is_expanded = !node.is_expanded;
                log::trace!("Toggled expand state for node {}", node_id);
            }
        } else {
            log::warn!(
                "Attempted to toggle expand state for invalid node ID: {}",
                node_id
            );
        }
    }

    /// Sets the state of all nodes to Checked.
    fn perform_select_all_nodes(&mut self) {
        if let Some(root_id) = self.root_id {
            self.set_node_state_recursive(root_id, Check::Checked);
            // No need to update parents as everything is checked
            log::info!("Selected all nodes.");
        }
    }

    /// Sets the state of all nodes to Unchecked.
    fn perform_deselect_all_nodes(&mut self) {
        if let Some(root_id) = self.root_id {
            self.set_node_state_recursive(root_id, Check::Unchecked);
            // No need to update parents as everything is unchecked
            log::info!("Deselected all nodes.");
        }
    }

    /// Expands all directory nodes.
    fn perform_expand_all_nodes(&mut self) {
        if let Some(root_id) = self.root_id {
            self.set_node_expansion_recursive(root_id, true);
            log::info!("Expanded all nodes.");
        }
    }

    /// Collapses all directory nodes (except the root).
    fn perform_collapse_all_nodes(&mut self) {
        if let Some(root_id) = self.root_id {
            self.set_node_expansion_recursive(root_id, false);
            // Ensure the root itself remains expanded for visibility
            if let Some(node) = self.nodes.get_mut(root_id) {
                node.is_expanded = true;
            }
            log::info!("Collapsed all nodes (except root).");
        }
    }

    /// Selects all direct children of a given node.
    fn perform_select_all_children(&mut self, node_id: FileId) {
        if let Some(node) = self.nodes.get(node_id) {
            if !node.is_dir() {
                return;
            }
            let children = node.children.clone(); // Clone to avoid borrow issues
            for child_id in children {
                self.set_node_state_recursive(child_id, Check::Checked);
            }
            self.update_parent_states(node_id); // Update starting from the parent
            log::debug!("Selected all children of node {}", node_id);
        }
    }

    /// Deselects all direct children of a given node.
    fn perform_deselect_all_children(&mut self, node_id: FileId) {
        if let Some(node) = self.nodes.get(node_id) {
            if !node.is_dir() {
                return;
            }
            let children = node.children.clone(); // Clone to avoid borrow issues
            for child_id in children {
                self.set_node_state_recursive(child_id, Check::Unchecked);
            }
            self.update_parent_states(node_id); // Update starting from the parent
            log::debug!("Deselected all children of node {}", node_id);
        }
    }

    /// Opens the node's path in the default system application.
    fn perform_open_node_externally(&mut self, node_id: FileId) {
        if let Some(node) = self.nodes.get(node_id) {
            let path = node.path();
            log::info!("Attempting to open path externally: {}", path.display());
            if let Err(e) = external::open_path_in_external_app(path) {
                log::error!("Failed to open path externally: {}", e);
                self.status_message = format!("Error opening path: {}", e);
                // Optionally show a dialog
                rfd::MessageDialog::new()
                    .set_level(rfd::MessageLevel::Error)
                    .set_title("Open Error")
                    .set_description(format!("Could not open '{}':\n{}", path.display(), e))
                    .show();
            }
        } else {
            log::warn!("Attempted to open invalid node ID externally: {}", node_id);
        }
    }

    /// Saves the current selection state to a JSON file.
    fn perform_save_selection(&mut self) {
        if self.root_path.is_none() || self.root_id.is_none() {
            self.status_message = "No directory open to save selection from.".to_string();
            log::warn!("Save selection attempted with no directory open.");
            return;
        }

        // Suggest a default filename based on the root directory name
        let default_name = format!(
            "{}_selection.json",
            self.root_path
                .as_ref()
                .unwrap() // Safe unwrap due to check above
                .file_name()
                .map_or("codebase", |n| n.to_str().unwrap_or("codebase"))
        );

        // Show the save file dialog
        if let Some(save_path) = rfd::FileDialog::new()
            .add_filter("JSON Files", &["json"])
            .set_file_name(&default_name)
            .save_file()
        {
            match selection::save_selection_to_file(
                &self.nodes,
                self.root_id,
                self.root_path.as_ref().unwrap(), // Safe unwrap
                &save_path,
            ) {
                Ok(_) => {
                    self.status_message = format!("Selection saved to {}", save_path.display());
                }
                Err(e) => {
                    log::error!("Failed to save selection: {}", e);
                    self.status_message = format!("Error saving selection: {}", e);
                    rfd::MessageDialog::new()
                        .set_level(rfd::MessageLevel::Error)
                        .set_title("Save Selection Failed")
                        .set_description(format!("Could not save selection:\n{}", e))
                        .show();
                }
            }
        } else {
            self.status_message = "Save selection cancelled.".to_string();
        }
    }

    /// Loads selection state from a JSON file.
    fn perform_load_selection(&mut self) {
        if self.root_path.is_none() || self.root_id.is_none() {
            self.status_message = "No directory open to load selection into.".to_string();
            log::warn!("Load selection attempted with no directory open.");
            return;
        }

        // Show the open file dialog
        if let Some(load_path) = rfd::FileDialog::new()
            .add_filter("JSON Files", &["json"])
            .pick_file()
        {
            match selection::load_selection_from_file(&mut self.nodes, self.root_id, &load_path) {
                Ok(saved_root_path_str) => {
                    let current_root_str = self.root_path.as_ref().unwrap().display().to_string(); // Safe unwrap
                    if saved_root_path_str != current_root_str {
                        log::warn!(
                            "Loaded selection for different root ('{}') than current ('{}').",
                            saved_root_path_str,
                            current_root_str
                        );
                        self.status_message = format!(
                            "Warning: Loaded selection for different root: {}",
                            saved_root_path_str
                        );
                        // Show a warning dialog
                        rfd::MessageDialog::new()
                            .set_level(rfd::MessageLevel::Warning)
                            .set_title("Load Selection Warning")
                            .set_description(format!(
                                "The loaded selection file was created for a different directory:\n\n{}\n\nSelection has been applied based on matching relative paths.",
                                saved_root_path_str
                            ))
                            .show();
                    } else {
                        self.status_message =
                            format!("Selection loaded from {}", load_path.display());
                    }

                    // Recalculate parent states after loading to ensure consistency
                    if let Some(root_id) = self.root_id {
                        self.recalculate_all_parent_states(root_id);
                    }
                }
                Err(e) => {
                    log::error!("Failed to load selection: {}", e);
                    self.status_message = format!("Error loading selection: {}", e);
                    rfd::MessageDialog::new()
                        .set_level(rfd::MessageLevel::Error)
                        .set_title("Load Selection Failed")
                        .set_description(format!("Could not load selection:\n{}", e))
                        .show();
                }
            }
        } else {
            self.status_message = "Load selection cancelled.".to_string();
        }
    }

    /// Generates a report in a background thread based on the provided options.
    fn perform_generate_report(&mut self, options: ReportOptions) {
        if self.is_scanning || self.is_generating_report {
            log::warn!("Cannot generate report: Another background task is running.");
            self.status_message = "Busy with another task (scan/report).".to_string();
            return;
        }
        if self.root_path.is_none() || self.root_id.is_none() {
            self.status_message = "No directory open to generate report from.".to_string();
            log::warn!("Generate report attempted with no directory open.");
            return;
        }

        // Determine default file extension and name
        let default_ext = match options.format {
            ReportFormat::Markdown => "md",
            ReportFormat::Html => "html",
            ReportFormat::Text => "txt",
        };
        let default_name = format!(
            "{}_report.{}",
            self.root_path
                .as_ref()
                .unwrap() // Safe unwrap
                .file_name()
                .map_or("codebase", |n| n.to_str().unwrap_or("codebase")),
            default_ext
        );

        // Show save file dialog
        if let Some(save_path) = rfd::FileDialog::new()
            .add_filter(
                format!("{:?} Report", options.format).as_str(),
                &[default_ext],
            )
            .set_file_name(&default_name)
            .save_file()
        {
            self.status_message = "Generating report in background...".to_string();
            self.is_generating_report = true;

            // Collect data synchronously *before* spawning the thread.
            // This borrows `self` briefly but avoids complex lifetime issues with the thread.
            let report_data_result = report::collect_report_data(self, &options);
            let task_sender = self.task_sender.clone().expect("Task sender should exist");
            let report_options = options.clone(); // Clone options for the thread

            // Spawn the report generation thread
            let handle = std::thread::spawn(move || {
                match report_data_result {
                    Ok(data) => {
                        // Send progress update
                        let _ = task_sender.send(TaskMessage::ReportProgress(
                            "Formatting report...".to_string(),
                        ));

                        // Format the report content
                        match report::format_report_content(&data, &report_options) {
                            Ok(report_content) => {
                                let _ = task_sender.send(TaskMessage::ReportProgress(format!(
                                    "Saving report to {}...",
                                    save_path.display()
                                )));

                                // Write the report to the file
                                match std_fs::write(&save_path, report_content) {
                                    Ok(_) => {
                                        // Send success message
                                        let _ = task_sender
                                            .send(TaskMessage::ReportFinished(Ok(save_path)));
                                    }
                                    Err(e) => {
                                        // Send file write error message
                                        let err_msg = format!("Failed to write report file: {}", e);
                                        log::error!("{}", err_msg);
                                        let _ = task_sender
                                            .send(TaskMessage::ReportFinished(Err(err_msg)));
                                    }
                                }
                            }
                            Err(e) => {
                                // Send formatting error message
                                let err_msg = format!("Failed to format report content: {}", e);
                                log::error!("{}", err_msg);
                                let _ = task_sender.send(TaskMessage::ReportFinished(Err(err_msg)));
                            }
                        }
                    }
                    Err(e) => {
                        // Send data collection error message
                        let err_msg = format!("Failed to collect report data: {}", e);
                        log::error!("{}", err_msg);
                        let _ = task_sender.send(TaskMessage::ReportFinished(Err(err_msg)));
                    }
                }
            });

            self.background_task = Some(BackgroundTask::Report(handle));
        } else {
            self.status_message = "Report generation cancelled.".to_string();
        }
    }

    /// Generates a report and copies the content to the clipboard.
    fn perform_copy_report(&mut self, options: ReportOptions) {
        if self.is_scanning || self.is_generating_report {
            log::warn!("Cannot copy report: Another background task is running.");
            self.status_message = "Busy with another task (scan/report).".to_string();
            return;
        }
        if self.root_path.is_none() || self.root_id.is_none() {
            self.status_message = "No directory open to generate report from.".to_string();
            log::warn!("Copy report attempted with no directory open.");
            return;
        }

        match report::generate_report(self, &options) {
            Ok(content) => match Clipboard::new() {
                Ok(mut clipboard) => {
                    if let Err(e) = clipboard.set_text(content) {
                        log::error!("Failed to copy report to clipboard: {}", e);
                        self.status_message = format!("Error copying report: {}", e);
                        rfd::MessageDialog::new()
                            .set_level(rfd::MessageLevel::Error)
                            .set_title("Copy Report Failed")
                            .set_description(format!("Could not copy report:\n{}", e))
                            .show();
                    } else {
                        self.status_message = "Report copied to clipboard.".to_string();
                    }
                }
                Err(e) => {
                    log::error!("Failed to access clipboard: {}", e);
                    self.status_message = format!("Clipboard error: {}", e);
                    rfd::MessageDialog::new()
                        .set_level(rfd::MessageLevel::Error)
                        .set_title("Clipboard Error")
                        .set_description(format!("Could not access clipboard:\n{}", e))
                        .show();
                }
            },
            Err(e) => {
                log::error!("Failed to generate report for clipboard: {}", e);
                self.status_message = format!("Error generating report: {}", e);
                rfd::MessageDialog::new()
                    .set_level(rfd::MessageLevel::Error)
                    .set_title("Report Generation Failed")
                    .set_description(format!("Could not generate report:\n{}", e))
                    .show();
            }
        }
    }

    /// Sets the focus flag for the search box.
    fn perform_focus_search_box(&mut self) {
        self.focus_search_box = true;
        // The UI update loop will check this flag and request focus.
    }

    // --- Helper Methods ---

    /// Recursively sets the check state for a node and all its descendants.
    fn set_node_state_recursive(&mut self, node_id: FileId, state: Check) {
        let mut queue = vec![node_id];
        while let Some(current_id) = queue.pop() {
            if let Some(node) = self.nodes.get_mut(current_id) {
                node.state = state;
                // Only recurse if it's a directory
                if node.is_dir() {
                    queue.extend(node.children.clone()); // Clone to avoid borrow issues
                }
            }
        }
    }

    /// Recursively sets the expansion state for a node and all its descendants.
    fn set_node_expansion_recursive(&mut self, node_id: FileId, expand: bool) {
        let mut queue = vec![node_id];
        while let Some(current_id) = queue.pop() {
            if let Some(node) = self.nodes.get_mut(current_id) {
                if node.is_dir() {
                    node.is_expanded = expand;
                    queue.extend(node.children.clone()); // Clone to avoid borrow issues
                }
            }
        }
    }

    /// Updates the check state of ancestor nodes based on their children's states.
    /// Traverses up the tree from the `start_node_id`.
    fn update_parent_states(&mut self, start_node_id: FileId) {
        let mut current_id_opt = Some(start_node_id);
        while let Some(current_id) = current_id_opt {
            // Find the parent of the current node
            if let Some(parent_id) = self.find_parent_id(current_id) {
                // Calculate the new state the parent *should* have based on its children
                let new_parent_state = self.calculate_parent_check_state(parent_id);
                // Get the parent node mutably
                if let Some(parent_node) = self.nodes.get_mut(parent_id) {
                    // If the state hasn't changed, we can stop traversing up
                    if parent_node.state == new_parent_state {
                        break;
                    }
                    // Otherwise, update the parent's state and continue upwards
                    parent_node.state = new_parent_state;
                    current_id_opt = Some(parent_id);
                } else {
                    // Parent node not found (shouldn't happen in a valid tree)
                    break;
                }
            } else {
                // No parent found (reached the root or an orphaned node)
                break;
            }
        }
    }

    /// Recalculates the check state for all nodes in the subtree starting from `node_id`.
    /// Used after loading a selection to ensure parent states are correct.
    fn recalculate_all_parent_states(&mut self, node_id: FileId) {
        // Post-order traversal: Recalculate children first
        let children = self
            .nodes
            .get(node_id)
            .map_or(Vec::new(), |n| n.children.clone());
        for child_id in children {
            self.recalculate_all_parent_states(child_id);
        }

        // Then recalculate the current node if it's a directory
        if let Some(node) = self.nodes.get(node_id) {
            if node.is_dir() && !node.children.is_empty() {
                let new_state = self.calculate_parent_check_state(node_id);
                // Need mutable access again
                if let Some(node_mut) = self.nodes.get_mut(node_id) {
                    node_mut.state = new_state;
                }
            }
        }
    }

    /// Finds the `FileId` of the parent node containing `child_id`.
    fn find_parent_id(&self, child_id: FileId) -> Option<FileId> {
        // Iterate through all nodes and check if their children list contains the child_id
        self.nodes
            .iter()
            .position(|node| node.children.contains(&child_id))
    }

    /// Calculates the correct `Check` state for a parent node based on its children's states.
    fn calculate_parent_check_state(&self, parent_id: FileId) -> Check {
        if let Some(parent_node) = self.nodes.get(parent_id) {
            // If not a directory or has no children, its state is determined directly
            if !parent_node.is_dir() || parent_node.children.is_empty() {
                return parent_node.state;
            }

            let mut has_checked = false;
            let mut has_unchecked = false;
            let mut has_partial = false;

            // Check the state of each child
            for &child_id in &parent_node.children {
                if let Some(child_node) = self.nodes.get(child_id) {
                    match child_node.state {
                        Check::Checked => has_checked = true,
                        Check::Unchecked => has_unchecked = true,
                        Check::Partial => has_partial = true,
                    }
                }
                // Early exit optimization: if we have both checked/partial and unchecked, it's Partial
                if (has_checked || has_partial) && has_unchecked {
                    return Check::Partial;
                }
                // If any child is partial, the parent must be partial
                if has_partial {
                    return Check::Partial;
                }
            }

            // Determine final state based on children
            if has_checked && !has_unchecked {
                // All children are Checked
                Check::Checked
            } else if !has_checked && has_unchecked {
                // All children are Unchecked
                Check::Unchecked
            } else {
                // Mix of Checked and Unchecked (but no Partial)
                Check::Partial
            }
        } else {
            // Node not found, return default state
            Check::Unchecked
        }
    }

    /// Counts the total number of files and the number of selected files.
    /// Returns `(total_files, selected_files)`.
    pub fn count_files(&self) -> (usize, usize) {
        let mut total = 0;
        let mut selected = 0;
        for node in &self.nodes {
            if !node.is_dir() {
                // Only count files
                total += 1;
                if node.state == Check::Checked {
                    selected += 1;
                }
            }
        }
        (total, selected)
    }

    /// Helper function to process the addition of a single FileNode.
    /// Contains the logic previously inside the ScanMessage::AddNode match arm.
    fn add_single_node(&mut self, node: FileNode) {
        let node_path = node.path().to_path_buf();
        let node_id = self.nodes.len(); // ID will be the next index

        // Determine parent path
        let parent_path_opt = node_path.parent().map(|p| p.to_path_buf());

        // Add the node to the arena *first*
        self.nodes.push(node); // node is moved here
                               // Populate the path map *after* pushing the node
        self.path_to_id_map.insert(node_path.clone(), node_id);

        // --- Root Node Handling ---
        // Check if this is the root node we started scanning
        if self.root_id.is_none() && Some(&node_path) == self.root_path.as_ref() {
            self.root_id = Some(node_id);
            if let Some(root_node) = self.nodes.get_mut(node_id) {
                root_node.is_expanded = true; // Expand root by default
            }
            log::debug!(
                "Root node added: ID {}, Path: {}",
                node_id,
                node_path.display()
            );
        }

        // --- Parent Linking & Orphan Handling ---
        let mut parent_found = false;
        if let Some(parent_path) = parent_path_opt.as_ref() {
            // Try to find the parent node using the HashMap
            if let Some(&parent_id) = self.path_to_id_map.get(parent_path) {
                // If parent found, add the current node as its child
                if let Some(parent_node) = self.nodes.get_mut(parent_id) {
                    parent_node.children.push(node_id);
                    parent_found = true;
                    // log::trace!("Linked node {} ({}) to parent {}", node_id, node_path.display(), parent_id);

                    // Check if this newly added node was a missing parent for any orphans
                    if let Some(orphans) = self.orphaned_children.remove(&node_path) {
                        log::debug!(
                            "Node {} ({}) resolved {} orphans.",
                            node_id,
                            node_path.display(),
                            orphans.len()
                        );
                        // Add the resolved orphans as children of the new node
                        if let Some(new_parent_node) = self.nodes.get_mut(node_id) {
                            for (orphan_id, _) in orphans {
                                new_parent_node.children.push(orphan_id);
                            }
                        }
                    }
                }
            }
        }

        // --- Orphan Handling ---
        // If parent wasn't found *and* this isn't the root node, store it as an orphan
        if !parent_found && self.root_id != Some(node_id) {
            if let Some(parent_path) = parent_path_opt {
                log::trace!(
                    "Orphaned node {} (parent {} not found yet). Storing.",
                    node_path.display(),
                    parent_path.display()
                );
                self.orphaned_children
                    .entry(parent_path) // Group orphans by their missing parent's path
                    .or_default()
                    .push((node_id, node_path.clone())); // Store child ID and path, clone path
            } else if self.root_id.is_none() {
                // This case should ideally not happen if root handling is correct
                log::error!(
                    "Node {} has no parent but is not root, and root not yet found.",
                    node_path.display()
                );
            }
        }

        // Update scan statistics using the info from the *added* node
        if let Some(stats) = self.scan_stats.as_mut() {
            if let Some(root_p) = &self.root_path {
                // Access the node we just pushed
                if let Some(added_node_info) = self.nodes.get(node_id).map(|n| &n.info) {
                    stats.add_file(added_node_info, root_p);
                }
            }
        }
    }

    // --- Message Handling ---

    /// Processes messages received from the background scanner thread.
    fn handle_scan_messages(&mut self) {
        if let Some(receiver) = self.scan_receiver.clone() {
            // Clone receiver for the loop
            while let Ok(msg) = receiver.try_recv() {
                match msg {
                    ScanMessage::AddNode(node) => {
                        self.add_single_node(node);
                    }
                    ScanMessage::AddNodes(nodes) => {
                        // log::trace!("Processing batch of {} nodes", nodes.len()); // Optional: Log batch processing
                        for node in nodes {
                            self.add_single_node(node);
                        }
                    }
                    ScanMessage::Error(err_msg) => {
                        log::error!("Scan error reported: {}", err_msg);
                        self.status_message = format!("Scan error: {}", err_msg);
                        if let Some(stats) = self.scan_stats.as_mut() {
                            stats.add_error(err_msg);
                        }
                        // Consider stopping the scan or showing a dialog for critical errors
                    }
                    ScanMessage::Progress(msg) => {
                        // Update status bar message
                        self.status_message = msg;
                    }
                    ScanMessage::Stats(partial_stats) => {
                        // Merge partial stats if the scanner sends them (optional)
                        if let Some(total_stats) = self.scan_stats.as_mut() {
                            total_stats.merge(partial_stats);
                        }
                    }
                    ScanMessage::Finished => {
                        log::info!("Scan finished message received.");
                        self.is_scanning = false;
                        self.background_task = None; // Clear the task handle
                        self.scan_receiver = None; // Drop the receiver

                        // Finalize status message
                        if let Some(stats) = self.scan_stats.as_mut() {
                            stats.finalize(); // Perform any final calculations on stats
                            self.status_message = format!(
                                "Scan complete: {} files, {} dirs, {}",
                                stats.total_files,
                                stats.total_dirs,
                                stats.total_size_human()
                            );
                        } else {
                            self.status_message = "Scan complete.".to_string();
                        }

                        // Log any remaining orphans (indicates potential issues)
                        if !self.orphaned_children.is_empty() {
                            log::warn!(
                                "Scan finished with {} unresolved orphan parent path(s). This might indicate missing directory entries.",
                                self.orphaned_children.len()
                            );
                            for (parent, children) in &self.orphaned_children {
                                log::warn!(" - Missing Parent: {}", parent.display());
                                for (_, child_path) in children.iter().take(5) {
                                    log::warn!("   - Orphaned Child: {}", child_path.display());
                                }
                                if children.len() > 5 {
                                    log::warn!(
                                        "   - ...and {} more orphans for this parent",
                                        children.len() - 5
                                    );
                                }
                            }
                            // Clear the map after logging
                            self.orphaned_children.clear();
                        }

                        // Sort nodes alphabetically, directories first
                        self.sort_nodes_recursively(self.root_id);

                        // Auto-expand small directories based on config
                        if let Some(stats) = &self.scan_stats {
                            if self.config.auto_expand_limit > 0
                                && stats.total_files <= self.config.auto_expand_limit
                            {
                                log::info!(
                                    "Auto-expanding nodes as total file count ({}) <= limit ({}).",
                                    stats.total_files,
                                    self.config.auto_expand_limit
                                );
                                if let Some(root_id) = self.root_id {
                                    // Expand direct children of the root
                                    if let Some(root_node) = self.nodes.get(root_id) {
                                        let children = root_node.children.clone();
                                        for child_id in children {
                                            if let Some(child_node) = self.nodes.get_mut(child_id) {
                                                child_node.is_expanded = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /// Processes messages received from background task threads (currently only report generation).
    fn handle_task_messages(&mut self) {
        if let Some(receiver) = self.task_receiver.clone() {
            // Clone receiver for the loop
            while let Ok(msg) = receiver.try_recv() {
                match msg {
                    TaskMessage::ReportProgress(status) => {
                        self.status_message = status;
                    }
                    TaskMessage::ReportFinished(result) => {
                        self.is_generating_report = false;
                        self.background_task = None; // Clear the task handle

                        match result {
                            Ok(save_path) => {
                                self.status_message =
                                    format!("Report saved successfully to {}", save_path.display());
                                log::info!(
                                    "Report generated successfully to {}",
                                    save_path.display()
                                );

                                // Ask user if they want to open the generated report
                                if rfd::MessageDialog::new()
                                    .set_level(rfd::MessageLevel::Info)
                                    .set_title("Report Generated")
                                    .set_description(format!(
                                        "Report saved to:\n{}\n\nWould you like to open it?",
                                        save_path.display()
                                    ))
                                    .set_buttons(rfd::MessageButtons::YesNo)
                                    .show()
                                    == MessageDialogResult::Yes
                                {
                                    if let Err(e) = external::open_path_in_external_app(&save_path)
                                    {
                                        log::error!("Failed to open generated report file: {}", e);
                                        self.status_message =
                                            format!("Error opening report: {}", e);
                                        // Show error dialog as well
                                        rfd::MessageDialog::new()
                                            .set_level(rfd::MessageLevel::Error)
                                            .set_title("Open Report Error")
                                            .set_description(format!(
                                                "Could not open report file:\n{}",
                                                e
                                            ))
                                            .show();
                                    }
                                }
                            }
                            Err(err_msg) => {
                                log::error!("Report generation failed: {}", err_msg);
                                self.status_message =
                                    format!("Error generating report: {}", err_msg);
                                // Show error dialog to the user
                                rfd::MessageDialog::new()
                                    .set_level(rfd::MessageLevel::Error)
                                    .set_title("Report Generation Failed")
                                    .set_description(&err_msg)
                                    .show();
                            }
                        }
                    }
                }
            }
        }
    }

    // Removed find_node_by_path as it's replaced by path_to_id_map lookup

    /// Recursively sorts the children of each node (directories first, then alphabetically).
    fn sort_nodes_recursively(&mut self, node_id_opt: Option<FileId>) {
        if let Some(node_id) = node_id_opt {
            // 1️⃣ take a *temporary* mutable borrow, just long enough to grab the list
            if let Some(node) = self.nodes.get_mut(node_id) {
                if node.is_dir() && !node.children.is_empty() {
                    // Move the children out of the node; this ends the mutable borrow.
                    let mut children = std::mem::take(&mut node.children);

                    // 2️⃣ immutable access is now legal because the mutable borrow is over
                    children.sort_by_cached_key(|&child_id| {
                        let child = &self.nodes[child_id];
                        (!child.is_dir(), child.name().to_lowercase())
                    });

                    // 3️⃣ write the sorted list back (fresh mutable borrow)
                    if let Some(node) = self.nodes.get_mut(node_id) {
                        node.children = children.clone();
                    }

                    // 4️⃣ recurse
                    for child_id in children {
                        self.sort_nodes_recursively(Some(child_id));
                    }
                }
            }
        }
    }

    /// Initiates loading the preview content for the specified node in a background thread.
    /// The result will be sent back via the `preview_receiver`.
    pub fn load_preview_for_node(&mut self, node_id: FileId, ctx: &Context) {
        if let Some(node) = self.nodes.get(node_id) {
            // Don't load previews for directories
            if node.is_dir() {
                self.preview_cache = None; // Clear cache when selecting a directory
                return;
            }

            // --- Cache Check ---
            // Check if a valid cache entry already exists for this node and current theme.
            if let Some(cache_mutex) = &self.preview_cache {
                // Use try_lock to avoid blocking the UI thread if the cache is being updated.
                if let Ok(cache) = cache_mutex.try_lock() {
                    // Determine the theme name that *would* be used for the preview
                    let current_theme_name = self.get_current_syntax_theme_name();

                    // Check if node ID matches and if the theme used matches (only relevant for text)
                    let theme_matches = match cache.content {
                        PreviewContent::Text(_) => {
                            cache.theme_used.as_deref() == Some(&current_theme_name)
                        }
                        _ => true, // Theme doesn't matter for images or errors
                    };

                    if cache.node_id == node_id && theme_matches {
                        log::trace!("Preview cache hit for node {}", node_id);
                        return; // Cache is valid, no need to reload
                    }
                }
                // If try_lock fails, it means the preview is likely being generated, so we wait.
            }

            // --- Start Background Loading ---
            log::trace!("Initiating preview load for node {}", node_id);
            let path = node.path().to_path_buf();
            let cfg = self.config.clone(); // Clone config for the thread
            let ss = self.syntax_set; // Static refs are Send + Sync
            let ts = self.theme_set;
            let tx = self
                .preview_sender
                .as_ref()
                .expect("Preview sender missing")
                .clone();
            let ctx_clone = ctx.clone(); // Clone context for texture loading in thread

            // Spawn a background task using rayon or std::thread
            rayon::spawn_fifo(move || {
                // Generate the preview content (text, image, or error)
                let cache_entry =
                    preview::generate_preview(&cfg, ss, ts, &path, node_id, &ctx_clone);
                // Send the result back to the UI thread
                if tx.send((node_id, cache_entry)).is_err() {
                    // Log if the channel is closed (e.g., app shutting down)
                    log::warn!("Failed to send preview result: Channel closed.");
                }
            });
        } else {
            log::warn!("Attempted to load preview for invalid node ID: {}", node_id);
        }
    }

    /// Sets the egui visual theme (light/dark) based on the configuration.
    pub fn set_egui_theme(ctx: &Context, theme_name: &str) {
        log::info!("Setting application theme to: {}", theme_name);
        match theme_name {
            "dark" => ctx.set_visuals(Visuals::dark()),
            "light" => ctx.set_visuals(Visuals::light()),
            _ => {
                // "system" or unknown
                match dark_light::detect() {
                    Ok(dark_light::Mode::Dark) => {
                        log::info!("System theme detected: Dark");
                        ctx.set_visuals(Visuals::dark())
                    }
                    _ => {
                        // Light or unspecified/error
                        log::info!("System theme detected: Light (or default)");
                        ctx.set_visuals(Visuals::light())
                    }
                }
            }
        }
    }

    /// Helper to get the name of the syntax theme currently in use based on config.
    /// Used for cache validation.
    fn get_current_syntax_theme_name(&self) -> String {
        // This logic should match the theme selection in `preview.rs`
        match self.config.theme.as_str() {
            "dark" => preview::DEFAULT_DARK_THEME.to_string(),
            "light" => preview::DEFAULT_LIGHT_THEME.to_string(),
            _ => match dark_light::detect() {
                // System theme
                Ok(dark_light::Mode::Dark) => preview::DEFAULT_DARK_THEME.to_string(),
                _ => preview::DEFAULT_LIGHT_THEME.to_string(),
            },
        }
    }
} // End impl CodebaseApp

// --- eframe::App Implementation ---

impl eframe::App for CodebaseApp {
    /// Called each frame to update the application state and draw the UI.
    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
        // 1. Handle Background Task Messages
        self.handle_scan_messages();
        self.handle_task_messages(); // Handles report generation messages

        // 2. Handle Preview Results
        if let Some(rx) = &self.preview_receiver {
            for (id, cache_entry) in rx.try_iter() {
                // Only update the cache if the received preview is for the currently selected node
                if self.selected_node_id == Some(id) {
                    log::trace!("Received preview for selected node {}", id);
                    self.preview_cache = Some(Arc::new(Mutex::new(cache_entry)));
                } else {
                    // Log if we receive a preview for a node that's no longer selected
                    log::trace!(
                        "Received preview for node {}, but node {:?} is selected. Ignoring.",
                        id,
                        self.selected_node_id
                    );
                }
            }
        }

        // 3. Handle Keyboard Shortcuts
        // Define shortcuts using egui::KeyboardShortcut for cross-platform handling (Cmd/Ctrl)
        let open_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::O);
        let save_sel_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::S);
        let load_sel_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::L);
        let report_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::G);
        let select_all_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::A);
        let deselect_all_shortcut =
            egui::KeyboardShortcut::new(Modifiers::COMMAND.plus(Modifiers::SHIFT), Key::A);
        let find_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::F);
        let expand_all_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::OpenBracket); // Usually Cmd+[
        let collapse_all_shortcut =
            egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::CloseBracket); // Usually Cmd+]
        let toggle_preview_shortcut = egui::KeyboardShortcut::new(Modifiers::NONE, Key::F9);
        let prefs_shortcut = egui::KeyboardShortcut::new(Modifiers::COMMAND, Key::Comma); // Standard macOS prefs shortcut

        // Only process shortcuts if no text input field has focus
        if !ctx.wants_keyboard_input() {
            ctx.input_mut(|i| {
                if i.consume_shortcut(&open_shortcut) {
                    if let Some(path) = rfd::FileDialog::new().pick_folder() {
                        self.queue_action(AppAction::StartScan(path));
                    }
                } else if i.consume_shortcut(&save_sel_shortcut) && self.root_path.is_some() {
                    self.queue_action(AppAction::SaveSelection);
                } else if i.consume_shortcut(&load_sel_shortcut) && self.root_path.is_some() {
                    self.queue_action(AppAction::LoadSelection);
                } else if i.consume_shortcut(&report_shortcut)
                    && self.root_path.is_some()
                    && !self.is_scanning
                    && !self.is_generating_report
                {
                    self.show_report_options_window = true; // Open dialog first
                } else if i.consume_shortcut(&select_all_shortcut) && self.root_id.is_some() {
                    self.queue_action(AppAction::SelectAllNodes);
                } else if i.consume_shortcut(&deselect_all_shortcut) && self.root_id.is_some() {
                    self.queue_action(AppAction::DeselectAllNodes);
                } else if i.consume_shortcut(&find_shortcut) && self.root_id.is_some() {
                    self.queue_action(AppAction::FocusSearchBox);
                } else if i.consume_shortcut(&expand_all_shortcut) && self.root_id.is_some() {
                    self.queue_action(AppAction::ExpandAllNodes);
                } else if i.consume_shortcut(&collapse_all_shortcut) && self.root_id.is_some() {
                    self.queue_action(AppAction::CollapseAllNodes);
                } else if i.consume_shortcut(&toggle_preview_shortcut) {
                    self.show_preview_panel = !self.show_preview_panel;
                } else if i.consume_shortcut(&prefs_shortcut) {
                    self.show_preferences_window = true;
                }
                // Note: Exit shortcuts (Alt+F4, Cmd+Q) are usually handled by the OS/eframe directly.
            });
        }

        // 4. Draw UI Elements
        ui::draw_menu_bar(self, ctx);
        ui::draw_status_bar(self, ctx);

        // Left Panel (Tree View)
        SidePanel::left("tree_panel")
            .resizable(true)
            .default_width(350.0)
            .width_range(200.0..=800.0) // Allow wider panel
            .show(ctx, |ui| {
                let selected_before = self.selected_node_id;
                ui::draw_tree_panel(self, ui);
                let selected_after = self.selected_node_id;

                // If selection changed *and* it's a file, trigger preview load
                if selected_before != selected_after {
                    if let Some(new_id) = selected_after {
                        if let Some(node) = self.nodes.get(new_id) {
                            if !node.is_dir() {
                                self.load_preview_for_node(new_id, ctx);
                            } else {
                                // Clear preview when selecting a directory
                                self.preview_cache = None;
                            }
                        }
                    } else {
                        // Clear preview if selection is cleared
                        self.preview_cache = None;
                    }
                }
            });

        // Center/Right Panel (Preview or Placeholder)
        if self.show_preview_panel {
            CentralPanel::default().show(ctx, |ui| {
                ui::draw_preview_panel(self, ui);
            });
        } else {
            // Show a placeholder message if the preview panel is hidden
            CentralPanel::default().show(ctx, |ui| {
                ui.centered_and_justified(|ui| {
                    ui.label("Preview panel hidden (View > Show Preview Panel or F9)");
                });
            });
        }

        // Draw Modal Dialogs (if open)
        ui::draw_preferences_window(self, ctx);
        ui::draw_report_options_window(self, ctx);
        ui::draw_about_window(self, ctx);
        ui::draw_shortcuts_window(self, ctx);

        // 5. Process Deferred Actions
        // Apply state changes queued during UI drawing or shortcut handling
        let had_actions = !self.deferred_actions.is_empty();
        self.process_deferred_actions();

        // 6. Request Repaint if Necessary
        // Keep repainting if background tasks are running, actions were processed,
        // or focus needs to be set. Use a short delay to avoid busy-waiting.
        if self.is_scanning || self.is_generating_report || had_actions || self.focus_search_box {
            ctx.request_repaint_after(std::time::Duration::from_millis(30)); // Repaint fairly quickly if busy
        } else {
            // Otherwise, repaint less frequently when idle
            // ctx.request_repaint_after(std::time::Duration::from_millis(200));
            // Or rely on input events to trigger repaints (default eframe behavior)
        }
    }

    /// Called when the application is about to close.
    /// Used for saving state.
    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
        log::info!("Saving configuration on exit...");
        if let Err(e) = self.config.save() {
            // Log error, but don't prevent exit
            log::error!("Failed to save config on exit: {}", e);
        }
    }

    /// Called just before the application exits.
    /// Used for cleanup, like signaling background threads to stop.
    fn on_exit(&mut self, _gl: Option<&eframe::glow::Context>) {
        log::info!("Exit requested. Cleaning up background tasks...");

        // Signal scan cancellation if active
        if let Some(BackgroundTask::Scan(_, cancel)) = &self.background_task {
            log::info!("Requesting scan cancellation on exit...");
            cancel.store(true, Ordering::Relaxed);
            // Don't explicitly join the thread here, as it might block exit indefinitely.
            // The OS will clean up threads eventually.
        }

        // Handle report generation task (less critical to cancel cleanly)
        if let Some(BackgroundTask::Report(_)) = self.background_task.take() {
            log::info!("Report generation task was running during exit.");
            // We could try to join with a timeout, but it's often simpler
            // to just let it finish or be terminated by the OS.
            // handle.join().ok(); // Avoid joining without timeout on exit path
        }
    }
}
